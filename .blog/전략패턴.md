# 전략 패턴 정리 (ex01 기반)

## 1. ex01에서 보이는 핵심 구조
- `Animal`은 추상 클래스이며 `getName()`을 강제한다. (`src/ex01/Animal.java`)
- `Mouse`, `Tiger`는 `Animal`을 상속해 각자 이름을 제공한다. (`src/ex01/Mouse.java`, `src/ex01/Tiger.java`)
- `DoorMan`은 구체 타입이 아니라 `Animal` 타입을 받아 `쫓아내(Animal a)`를 수행한다. (`src/ex01/DoorMan.java`)
- `App`은 `DoorMan`에게 `Tiger`를 전달해 동일한 인터페이스로 동작시킨다. (`src/ex01/App.java`)

## 2. 왜 전략 패턴 관점으로 볼 수 있는가
이 예제는 "행동을 호출하는 쪽(`DoorMan`)"이 "구체 클래스(`Tiger`, `Mouse`)"에 직접 의존하지 않고, 추상화(`Animal`)를 통해 대상을 바꿔 끼울 수 있다는 점이 핵심이다.

즉, `DoorMan` 입장에서는 "어떤 동물인지"보다 "`Animal` 규약을 만족하는지"가 중요하며, 실행 시점에 전달되는 객체에 따라 결과가 달라진다.

## 3. 이 예제의 전략 요소
- 전략 인터페이스 역할: `Animal`
- 구체 전략 역할: `Tiger`, `Mouse`
- 컨텍스트 역할: `DoorMan`
- 실행(조립) 역할: `App`

## 4. 얻는 이점
- 새로운 동물 타입을 추가해도 `DoorMan` 코드를 수정하지 않아도 된다.
- `DoorMan`은 추상화에만 의존하므로 결합도가 낮아진다.
- 코드 주석에 적힌 DIP/OCP 의도를 코드 구조로 확인할 수 있다.

## 5. 참고
일반적인 GoF 전략 패턴은 "알고리즘(행동) 자체"를 인터페이스로 분리하는 형태가 더 전형적이다. 이 예제는 그 개념을 단순화해 "추상화에 의존하고, 런타임에 구현체를 교체"하는 핵심 아이디어를 보여준다.
