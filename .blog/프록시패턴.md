# 프록시 패턴 정리 (ex02 기반)

## 1. ex02에서 보이는 핵심 구조
- `Animal`은 공통 추상 타입이다. (`src/ex02/Animal.java`)
- `Tiger`, `Mouse`는 실제 요청 대상 데이터(이름)를 제공한다. (`src/ex02/Tiger.java`, `src/ex02/Mouse.java`)
- `DoorMan`은 원본 객체(Real Subject)로서 실제 업무인 `쫓아내(Animal a)`를 수행한다. (`src/ex02/DoorMan.java`)
- `DoorManProxy`는 `DoorMan`을 상속해 메서드 호출 전 `지갑 검사`를 수행한 뒤 `super.쫓아내(a)`를 호출한다. (`src/ex02/DoorManProxy.java`)
- `App`에서 `DoorMan doorMan = new DoorManProxy();`로 프록시를 주입해 원본 대신 사용한다. (`src/ex02/App.java`)

## 2. ex02를 통해 보는 프록시 패턴
프록시 패턴은 "실제 객체에 바로 접근하지 않고 대리 객체(Proxy)를 통해 접근"하게 만들어,
접근 제어, 로깅, 캐싱, 인증/인가, 지연 로딩 같은 부가 기능을 앞단에 추가하는 패턴이다.

ex02에서는 `DoorManProxy`가 대리 객체이며,
- 호출 전: `지갑 검사`(부가 기능)
- 호출 본체: `DoorMan`의 실제 `쫓아내` 로직
으로 역할이 분리되어 있다.

## 3. 이 예제의 장점
- 기존 `DoorMan` 코드를 수정하지 않고 부가 정책을 붙일 수 있다. (OCP)
- 클라이언트(`App`)는 `DoorMan` 타입으로 동일하게 사용 가능하다.
- 부가 기능과 핵심 기능이 분리되어 유지보수가 쉬워진다.

## 4. 포워드 프록시와 리버스 프록시

### 포워드 프록시 (Forward Proxy)
- 클라이언트 앞단에 위치한다.
- 클라이언트가 직접 외부 서버에 가지 않고 프록시를 통해 요청한다.
- 주 사용 목적: 익명성, 접근 제어, 캐시, 사내 정책 적용.
- 예: 회사 네트워크에서 특정 사이트 접근 정책을 프록시로 강제.

### 리버스 프록시 (Reverse Proxy)
- 서버 앞단에 위치한다.
- 클라이언트는 실제 백엔드 서버를 모르고 리버스 프록시로만 접근한다.
- 주 사용 목적: 로드밸런싱, SSL 종료, 캐시, 보안(백엔드 은닉).
- 예: `Nginx`가 앞에서 요청을 받아 여러 애플리케이션 서버로 분산.

## 5. ex02와의 연결 관점
- ex02는 "원본 객체 앞에 대리 객체를 두고 요청을 중간 제어"한다는 프록시의 핵심 아이디어를 코드 레벨로 보여준다.
- 네트워크의 포워드/리버스 프록시는 적용 위치(클라이언트 앞/서버 앞)는 다르지만,
  본질적으로 "중간 대리 계층에서 부가 기능과 제어를 수행"한다는 점은 동일하다.
