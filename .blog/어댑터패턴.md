# 어댑터 패턴 정리 (ex03 + mock 기반)

## 1. ex03에서 보는 어댑터 패턴

### 핵심 구조
- `DoorMan`은 `Animal` 타입만 받는다. (`src/ex03/DoorMan.java`)
- `Tiger`, `Mouse`는 `Animal`을 그대로 구현한 일반 객체다. (`src/ex03/Tiger.java`, `src/ex03/Mouse.java`)
- `OuterRabbit`은 외부 라이브러리 클래스라 인터페이스가 다르다. (`src/ex03/lib/OuterRabbit.java`)
  - `Animal#getName()`이 아니라 `getFullname()`을 제공한다.
- `RabbitAdapter`가 `OuterRabbit`을 감싸서 `Animal` 규약으로 변환한다. (`src/ex03/RabbitAdapter.java`)
  - `getName()` 호출을 내부적으로 `outerRabbit.getFullname()`으로 매핑한다.

### 해석
클라이언트(`DoorMan`)는 `Animal`만 알면 되므로,
외부 객체(`OuterRabbit`)를 직접 수정하지 않고도 `RabbitAdapter`를 통해 시스템에 연결할 수 있다.

## 2. mock 폴더와의 연결 포인트

### mock 구조
- `Meter` 인터페이스가 표준 계약이다. (`src/mock/Meter.java`)
- `MeterService`는 오직 `Meter`에 의존한다. (`src/mock/MeterService.java`)
- 개발 중에는 `MockMeter`를 연결해 선개발이 가능하다. (`src/mock/MockMeter.java`)
- 실제 구현 완료 후에는 `RealMeter`로 교체한다. (`src/mock/lib/RealMeter.java`, `src/mock/App.java`)

### 왜 어댑터와 같이 봐야 하는가
`mock`은 현재 `RealMeter`가 `Meter`를 이미 구현해서 바로 교체 가능하다.
하지만 실제 프로젝트에서는 외부/레거시 라이브러리가 인터페이스를 맞추지 못하는 경우가 많다.
그때 `RealMeterAdapter implements Meter` 같은 어댑터를 두면,
`MeterService` 코드를 바꾸지 않고 연결할 수 있다.

## 3. 두 예제로 정리한 어댑터 패턴의 핵심
- 목적: "호환되지 않는 인터페이스를 현재 시스템 표준 인터페이스로 변환"하는 것.
- 장점:
  - 기존 코드 수정 최소화
  - 외부 라이브러리/레거시 코드 재사용
  - 클라이언트 코드(`DoorMan`, `MeterService`) 안정성 유지
- 적용 시점:
  - 외부 객체를 직접 고칠 수 없을 때
  - 팀 간 개발 속도가 달라 임시 연결이 필요할 때
  - 나중에 실제 구현체를 붙여도 서비스 코드를 유지하고 싶을 때

## 4. 역할 매핑 (ex03 기준)
- Target(클라이언트가 기대하는 인터페이스): `Animal`
- Adaptee(기존/외부 클래스): `OuterRabbit`
- Adapter(변환자): `RabbitAdapter`
- Client(표준 인터페이스만 사용하는 쪽): `DoorMan`
